
//-------------------------------DEFINITIONS---------------------------------

//Pinout Definitions--------SIO#-------PIN#--------------------------------
#define HAPTIC			    1  	// 13, IO, IO; out. Formally HAPTIC_PWM. ACTIVE LOW
#define BUCK_ON				40	// 17, IO; out - LED 1
#define CURR_SET_PWM		11	// 19, IO, PWM; out 
#define TX_EN				25	// 23, IO; out - LED 2
#define MOD				    14	// 27, IO, FREQ; out 
#define RX_EN				17	// 28, IO; out - LED 3
#define BLINK				12	// 29, IO, interrupt; in - Button 1
#define ENV_ADC				3 	// 10, ADC; in
#define BAT_ADC				31	// 12, ADC; in
#define PBSTAT				28	// 36, IO; in
#define CHRG				30	// 38, IO; in
#define BLK_THRES_PWM		29	// 39, IO, PWM; out
#define SLOPE_P             27    // 40, IO, in
#define SLOPE_N             26    // 45, IO, in

#define DIGITAL_IN       1
#define DIGITAL_OUT      2
#define ANALOG_IN        3
#define LOW              0
#define HIGH             1
#define PWM              2
#define FREQ             3

//MAIN FSM STATE DEFINITIONS

#define TURN_OFF           0
#define TURN_ON            1
#define BLE_CONNECT        2
#define PROXIMITY_DETECT   3
#define CALIBRATION        4
#define CAL_PASS           5
#define CAL_FAIL           6
#define MODE_LP            7
#define MODE_HP            8
#define CHANGE_MODE        9


//BLUETOOTH DEFINITIONS
//Advertising Parameter definitions
#define ADV_TIMEOUT		   240000 //ms - how long before advertising timesout if no pair
#define ADV_INTERVAL       100 //ms note higher number means lower current consumption - time between advertisements
#define ADV_APPEARANCE     0 //might need to be 1?
#define DEVICENAME			"Laird BL653 Bioblink"
#define APPEARANCE         448 //no idea waht this is , just copied from bps>blood.presure.custom. Took value as 448 for eye glasses 

//Set BLE_DISCOVERABILITY_NONE if whitelist is enabled in BleAdvertStart()
//as the 4.0 spec says if whitelist is enabled then discoverability is not allowed
#define BLE_DISCOVERABILITY_NONE                    0
#define BLE_DISCOVERABILITY_LIMITED                 1
#define BLE_DISCOVERABILITY_GENERAL                 2
#define BLE_DISCOVERABILITY_BOTH                    3

//Connection Definitions
//Minimum acceptable connection interval (0.5 seconds)
#define MIN_CONN_INTERVAL                           7500
//Maximum acceptable connection interval (1 second).
#define MAX_CONN_INTERVAL                           100000
//Slave latency -- number of conn events that can be missed
//Effective Conn interval will be (SLAVE_LATENCY+1)*ACTUAL_CONN_INTERVAL
#define SLAVE_LATENCY                               1
//Connection supervisory timeout (4 seconds) - max 32 seconds
#define CONN_SUP_TIMEOUT                            4000000

//other Params and UUIDS
#define DEVICENAME_WRITABLE                   		1
#define DISCOVERY_MODE                              BLE_DISCOVERABILITY_GENERAL
#define MAX_DEVNAME_CHRS                            0

#define LT_BASE_UUID                         		"\56\9a\00\00\b8\7f\49\0c\92\cb\11\ba\5e\a5\16\7c\"
#define UUID_BATTERY_SERVICE                        0x180F //x
#define UUID_BAT_LEVEL_CHAR							0x2A19 //x
#define UUID_HAPTIC_FEEDBACK_COUNT					0x2030 //x
#define UUID_CURRENT_STATE							0x2031 //x
#define UUID_ENV_ADC								0x2032 //x
#define UUID_BLINK_SLOPES							0x2033 //x
#define UUID_TARGET_INTERVAL						0x2035 //x

//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                      0   //msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                   1   //msgCtx = connection handle
#define BLE_EVBLEMSGID_SERVICE_ERROR                4   //msgCtx = resultcode
#define BLE_EVBLEMSGID_NEW_BOND                     10  //msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE            14  //msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL       15  //msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER        16  //msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                 17  //msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                    18  //msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING        19  //msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                  20  //msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE             21  //msgCtx = connection handle

//BLE char properties definitions
#define BLE_CHAR_PROPERTIES_BROADCAST               0x01
#define BLE_CHAR_PROPERTIES_READ                    0x02
#define BLE_CHAR_PROPERTIES_WRITE_WO_RESPONSE       0x04
#define BLE_CHAR_PROPERTIES_WRITE                   0x08
#define BLE_CHAR_PROPERTIES_NOTIFY                  0x10
#define BLE_CHAR_PROPERTIES_INDICATE                0x20
#define BLE_CHAR_PROPERTIES_AUTH_SIGNED_WR          0x40
#define BLE_CHAR_PROPERTIES_RELIABLE_WRITE          0x80



//-----------------------GLOBAL VARIABLES--------------------------


//GENERAL GLOBAL VARIABLES
dim SAMPLE_INTERVAL : SAMPLE_INTERVAL = 10 // 1/SAMPLING_RATE, used when finding ENV_ADC Value
dim rc  //Result code
DIM CURRENT_STATE as integer : CURRENT_STATE = 0   //State Machine Variable
DIM HW_Debug : HW_Debug = 0        //Flag to bypass any BLE comms and calibration. When '1' Go straight to MODE_LP with default values
DIM MIN_TIME_BTWN_BLINKS : MIN_TIME_BTWN_BLINKS = 200 //2000 for testing with the devkit, 500 in practice  (?Confirm with Shanes graph)
//dim Current_set_tx_default : Current_set_tx_default = 30 
dim FEEDBACK_COUNT : FEEDBACK_COUNT = 0 //count of feedback instances in respective mode 
dim SLOPE_FLAG : SLOPE_FLAG = 0 //1 when SLOPE P edge detected, goes back to 0 when SLOPE N edge detected
dim MAX_BLINK_DURATION : MAX_BLINK_DURATION = 300 //Changes SLOPE_FLAG if Slope N has not been detected 
dim FIRST_BLINK_FLAG : FIRST_BLINK_FLAG = 1

//CALIBRATION MODE GLOBAL VARIABLES 
DIM Cal_Fail_Count : Cal_Fail_Count = 0 //failure counter.So it dosen't endlessly 'calibrate' if the proximity detection produces false positive/
DIM CALIBRATION_STATUS : CALIBRATION_STATUS = 1 

//LP MODE GLOBAL VARIABLES
DIM LP_LAST_BLINK_TIME : LP_LAST_BLINK_TIME = 0 //used in LP MODE to determine last blink time
DIM TARGET_BLINK_INTERVAL : TARGET_BLINK_INTERVAL = 4000 //in ms, currently set to 10 seconds
DIM LP_MODE_HOUSEKEEPING_INTERVAL : LP_MODE_HOUSEKEEPING_INTERVAL = 30000 //in ms, every 30 seconds

//HP MODE GLOBAL VARIABLES
dim START_TIME   //current tick value for delay (ms)
dim END_TIME     //final tick value for delay   (ms)
dim ADC_RAW      //latest raw adc sample
dim HP_LAST_BLINK_TIME : HP_LAST_BLINK_TIME = 0   //tick time of the current blink (ms), if there is one.

//CHANGE MODE STATE GLOBAL VARIABLES 
DIM CHANGE_MODE_Flag	  //flag to determine button handler function
DIM CHANGE_MODE_Counter   //counts buttons presses to change to respective mode

//BATTERY CHECK VALUES
Dim Battery_Check_Interval : Battery_Check_Interval = 1000

//BLE CONNECT GLOBAL VARIABLES
DIM STAND_ALONE : STAND_ALONE = 0 //if BLE Connection Fails, Stand alone will make Proximity Detect use default values
DIM addr$ : addr$ = ""
DIM adRpt$ as string :adRpt$ = "" //contains most recent advertise report
DIM scnRpt$ as string : scnRpt$ = "" //contains most recent scan report
dim advappearance : advappearance = ADV_APPEARANCE
dim advFlags : advFlags = DISCOVERY_MODE
dim dn$ : dn$ = DEVICENAME

dim bseUuid$ : bseUuid$=LT_BASE_UUID
//Laird Technologies Base UUID handle
dim hBseUuid : hBseUuid=BleHandleUuid128(bseUuid$)
dim hSvc  //service handler
dim hSerBat //gatt service 
dim hcharBatADC ///gatt server battery adc characteristic handle
dim hcharEnvADC ///gatt server envelope adc characteristic handle
dim hcharCurrentState ///gatt server Current State characteristic handle
dim hcharTargetInterval //gat server target interval state handle (value default is to be 10s)
dim hcharHFeedbackCount //gat server Feedback instances count 
dim hcharSlopes
dim nTxBufs //number of free tx buffers for notification
dim nCtx

//Specific Functions--------------------------------------------------------------

sub AssertRC(byval rc as integer,byval tag as integer)
  if (rc!=0) then
    print "Failed with ";integer.h' rc;" at tag ";tag;"\n"
  endif
endsub

sub DELAY_MS(BYVAL DELAY_TIME AS INTEGER)   //delay N milliseconds.

    dim START_TIME 
    START_TIME = GETTICKCOUNT()  //Get initial tick in ms
    dim END_TIME 
    END_TIME = START_TIME + DELAY_TIME      //Add delay to current tick

    WHILE GETTICKCOUNT() < END_TIME            //Waste power until END_TIME reached

    ENDWHILE 

endsub

sub IO_Config()

    DIM temp
	DIM nfreq : nfreq = 10000
	DIM nresolution : nresolution = 100
    temp = GPIOSETFUNC(CURR_SET_PWM,DIGITAL_OUT,PWM)
    temp = GPIOCONFIGPWM(nfreq,nresolution)                      //10kHz 1:100 resolution current set PWM
    //To set duty cycle -> change TX current: GPIOWRITE(CURR_SET_PWM, 0 to N) where N = 1 to 100 or 10000?  

    temp = GPIOSETFUNC(HAPTIC,DIGITAL_OUT,HIGH)          //HAPTICS will just be on/off not PWM. Active low.
    temp = GPIOSETFUNC(BUCK_ON,DIGITAL_OUT,HIGH)         
    temp = GPIOSETFUNC(TX_EN,DIGITAL_OUT,LOW) 
    temp = GPIOSETFUNC(RX_EN,DIGITAL_OUT,LOW)
    temp = GPIOSETFUNC(MOD,DIGITAL_OUT,LOW)              //unused with FE v2.0, set as low digital output.
    temp = GPIOSETFUNC(BLK_THRES_PWM,DIGITAL_OUT,LOW)    //unused with FE v2.0, set as low digital output.

    temp = GPIOSETFUNC(BLINK,DIGITAL_IN,0)               //unused with FE v2.0, set as digital input.
    temp = GPIOSETFUNC(PBSTAT,DIGITAL_IN,0) //note for the devkit, used 2, originally written as 0 though
    temp = GPIOSETFUNC(CHRG,DIGITAL_IN,0)
    temp = GPIOSETFUNC(SLOPE_P,DIGITAL_IN, 01) //changed 0 to 2 for devkit purposes           //Add deep sleep wake?
    temp = GPIOSETFUNC(SLOPE_N,DIGITAL_IN, 01) //changed 0 to 2 for devkit purposes        
    
    temp = GPIOSETFUNCEX(ENV_ADC,ANALOG_IN,"\16\0C\14")          
    temp = GPIOSETFUNCEX(BAT_ADC,ANALOG_IN,"\14\0C\28")//"\14\0C\28")
	
    PRINT "\n IO Configured"
    
    // Set ADC scaling so max analog voltage * Scaling < 0.6V (ADC reference)
    //0x16 1/6 scaling
    //0x15 1/5 scaling
    //0x14 1/4 scaling
    //0x13 1/3 scaling
    //0x12 1/2 scaling
    //0x11 1/1 scaling (Unity)
    //0x21 2/1 scaling
    //0x41 4/1 scaling
    
    //0x08 8-bit ADC resolution
    //0x0A 10-bit ADC resolution
    //0x0C 12-bit ADC resolution

    //0x03 3 microseconds Acquisition time
    //0x05 5 microseconds
    //0x0A 10 microseconds
    //0x0F 15 microseconds
    //0x14 20 microseconds
    //0x28 40 microseconds
    
endsub 

sub CANCEL_ALL_TIMERS() //cancels all timers
	dim i : i = 0
	FOR i = 0 to 7
		TimerCancel(i)
	NEXT
	print "\n all 8 timers cancelled \n"
endsub

  
Sub Create_Char_Bat()
    dim dta$ : dta$="\00"
    dim rc2,rc3
	dim chprop
	
	dim format : format = 0x0E            //uint8 - Unsigned 16-bit integer
	dim exponent : exponent = 0
	dim unit : unit = 0x2700              //unitless
	dim namespace : namespace = 0x01      //Bluetooth SIG
	dim namespacedesc : namespacedesc = 0x0000
    //Initialise GATT Server batt read / notify LEDs Characteristic - Read/Write
	chprop = BLE_CHAR_PROPERTIES_READ | BLE_CHAR_PROPERTIES_NOTIFY //replace 0x22
	rc=BleCharNew(chprop, BleHandleUuidSibling(hBseUuid,(UUID_BAT_LEVEL_CHAR)), BleAttrMetaData(1,0,2,1,rc2), BleAttrMetaData(1,1,1,1,rc3),0)
    rc = BleCharDescPrstnFrmt(format,exponent,unit,namespace,namespacedesc)
	AssertRC(rc,155) : AssertRC(rc2,1552)
    rc=BleCharCommit(hSvc,dta$,hcharBatADC)
    AssertRC(rc,0604)
endsub

Sub Create_Char_Target_Interval()
    dim dta$ : dta$="\00"
    dim rc2,rc3
	dim chprop
	
	dim format : format = 0x0E            //uint8 - Unsigned 16-bit integer
	dim exponent : exponent = 0
	dim unit : unit = 0x2700              //unitless
	dim namespace : namespace = 0x01      //Bluetooth SIG
	dim namespacedesc : namespacedesc = 0x0000

	chprop = BLE_CHAR_PROPERTIES_READ | BLE_CHAR_PROPERTIES_WRITE 
	rc=BleCharNew(chprop, BleHandleUuidSibling(hBseUuid,(UUID_TARGET_INTERVAL)), BleAttrMetaData(1,1,2,1,rc2),0,0)
    rc = BleCharDescPrstnFrmt(format,exponent,unit,namespace,namespacedesc)
	AssertRC(rc,155) : AssertRC(rc2,1552)
    rc=BleCharCommit(hSvc,dta$,hcharTargetInterval)
    AssertRC(rc,0604)
endsub

Sub Create_Char_Current_State()
    dim dta$ : dta$="\00"
    dim rc2,rc3
	dim chprop
	
	dim format : format = 0x04            //uint8 - Unsigned 8-bit integer
	dim exponent : exponent = 0
	dim unit : unit = 0x2700              //unitless
	dim namespace : namespace = 0x01      //Bluetooth SIG
	dim namespacedesc : namespacedesc = 0x0000

    //Initialise GATT Server batt read / notify LEDs Characteristic - Read/Write
	chprop = BLE_CHAR_PROPERTIES_READ | BLE_CHAR_PROPERTIES_INDICATE //replace 0x22
	rc=BleCharNew(chprop, BleHandleUuidSibling(hBseUuid,(UUID_CURRENT_STATE)), BleAttrMetaData(1,0,2,1,rc2), BleAttrMetaData(1,1,1,1,rc3),0)
    rc = BleCharDescPrstnFrmt(format,exponent,unit,namespace,namespacedesc)
	AssertRC(rc,155) : AssertRC(rc2,1552)
    rc=BleCharCommit(hSvc,dta$,hcharCurrentState)
    AssertRC(rc,0604)
endsub

Sub Create_Char_Slope()
    dim dta$ : dta$="\00"
    dim rc2,rc3
	dim chprop
	
	dim format : format = 0x04            //uint8 - Unsigned 8-bit integer
	dim exponent : exponent = 0
	dim unit : unit = 0x2700              //unitless
	dim namespace : namespace = 0x01      //Bluetooth SIG
	dim namespacedesc : namespacedesc = 0x0000
    //Initialise GATT Server batt read / notify LEDs Characteristic - Read/Write

	chprop = BLE_CHAR_PROPERTIES_READ | BLE_CHAR_PROPERTIES_NOTIFY //replace 0x22
	rc=BleCharNew(chprop, BleHandleUuidSibling(hBseUuid,(UUID_BLINK_SLOPES)), BleAttrMetaData(1,0,2,1,rc2), BleAttrMetaData(1,1,1,1,rc3),0)
    rc = BleCharDescPrstnFrmt(format,exponent,unit,namespace,namespacedesc)
	AssertRC(rc,155) : AssertRC(rc2,1552)
    rc=BleCharCommit(hSvc,dta$,hcharSlopes)
    AssertRC(rc,0604)
endsub

Sub Create_Char_ENV_ADC()
    dim dta$ : dta$="\00"
    dim rc2,rc3
	dim chprop
	
	dim format : format = 0x0E            //uint8 - Unsigned 16-bit integer
	dim exponent : exponent = 0
	dim unit : unit = 0x2700              //unitless
	dim namespace : namespace = 0x01      //Bluetooth SIG
	dim namespacedesc : namespacedesc = 0x0000
    //Initialise GATT Server batt read / notify LEDs Characteristic - Read/Write
	chprop = BLE_CHAR_PROPERTIES_READ | BLE_CHAR_PROPERTIES_NOTIFY //replace 0x22
	rc=BleCharNew(chprop, BleHandleUuidSibling(hBseUuid,(UUID_ENV_ADC)), BleAttrMetaData(1,0,2,1,rc2), BleAttrMetaData(1,1,1,1,rc3),0)
    rc = BleCharDescPrstnFrmt(format,exponent,unit,namespace,namespacedesc)
	AssertRC(rc,155) : AssertRC(rc2,1552)
    rc=BleCharCommit(hSvc,dta$,hcharEnvADC)
    AssertRC(rc,0604)
endsub

Sub Create_Char_Feedback_Count()
    dim dta$ : dta$="\00"
    dim rc2,rc3
	dim chprop
	
	dim format : format = 0x04            //uint8 - Unsigned 8-bit integer
	dim exponent : exponent = 0
	dim unit : unit = 0x2700              //unitless
	dim namespace : namespace = 0x01      //Bluetooth SIG
	dim namespacedesc : namespacedesc = 0x0000
    //Initialise GATT Server batt read / notify LEDs Characteristic - Read/Write
	chprop = BLE_CHAR_PROPERTIES_READ | BLE_CHAR_PROPERTIES_NOTIFY //replace 0x22
	rc=BleCharNew(chprop, BleHandleUuidSibling(hBseUuid,(UUID_HAPTIC_FEEDBACK_COUNT)), BleAttrMetaData(1,0,2,1,rc2), BleAttrMetaData(1,1,1,1,rc3),0)
    rc = BleCharDescPrstnFrmt(format,exponent,unit,namespace,namespacedesc)
	AssertRC(rc,155) : AssertRC(rc2,1552)
    rc=BleCharCommit(hSvc,dta$,hcharHFeedbackCount)
    AssertRC(rc,0604)
endsub


Sub CreateSvc()

    //bat service UUID handle
    hSerBat=BleHandleUuidSibling(hBseUuid,UUID_BATTERY_SERVICE)

    //Create battery Service
    rc=BleServiceNew(1,hSerBat,hSvc)
    AssertRC(rc,0600)
	
	Create_Char_Bat()
	Create_Char_Current_State()
	Create_Char_Feedback_Count()
	Create_Char_ENV_ADC()
    Create_Char_Slope()
	Create_Char_Target_Interval()
  
    //Commit service to the GATT table
    rc=BleServiceCommit(hSvc)  
EndSub


sub MAKE_ADVERT_RPTS()
	rc = BleAdvRptInit(adRpt$,advFlags,ADV_APPEARANCE,MAX_DEVNAME_CHRS)
	AssertRC(rc, 433)
	rc=BleScanRptInit(scnRpt$)
    AssertRC(rc,179)
	print "\n Advert report created with new values \n"
	rc = BleAdvRptAppendAD(scnRpt$,0x09,dn$)
	AssertRC(rc,179)
	rc = BleAdvRptAddUuid128(adRpt$,hSerBat)
	rc = BleAdvRptsCommit(adRpt$,scnRpt$)
	//print "\n ADVRPT: ";adRpt$; "\n"
	//print "\n SCRPT: "; scnRpt$; "\n"
	print "\n advert reports commited \n"
	
endsub

sub START_ADVERTISING()
	print "\n BLE_CONNECT state start \n"
	IF BleAdvertStart(0,addr$,ADV_INTERVAL,ADV_TIMEOUT,0)==0 THEN
		PRINT "\nAdverts Started"
		PRINT "\nIf you search for Bluetooth devices on your device, you should see 'Laird BL653'"
	ELSE
		PRINT "\n\nAdvertisement not successful"
	ENDIF

ENDSUB

Sub OUTPUT_STATE(BYVAL STATE AS INTEGER)
	CURRENT_STATE = STATE
	dim value$ as string
	rc = BleEncode8(value$,CURRENT_STATE,0)
	rc = BleCharValueIndicate(hcharCurrentState,value$)
	print "\n CURRENT STATE BLE VALUE: ";value$;"\n" 
    
endsub

sub HAPTICS(BYVAL PATTERN_TYPE AS INTEGER)   //input an integer to select the haptic pattern
	FEEDBACK_COUNT = FEEDBACK_COUNT + 1 //increase feedback count with each Haptics call

	dim value$ as string //send feedback count via ble
	rc = BleEncode8(value$,FEEDBACK_COUNT,0)
	rc = BleCharValueNotify(hcharHFeedbackCount,value$)

    SELECT PATTERN_TYPE

        CASE 1                        //More Chill
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(90)
            GPIOWRITE(HAPTIC,1)
            DELAY_MS(90)
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(90)
            GPIOWRITE(HAPTIC,1)

            PRINT "\n Haptics 1 finished"

        CASE 2                        //Wild
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(200)
            GPIOWRITE(HAPTIC,1)
            DELAY_MS(200)
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(200)
            GPIOWRITE(HAPTIC,1)
			PRINT "\n Haptics 2 finished"
			
		CASE 3                         //Longer notification
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(50)
            GPIOWRITE(HAPTIC,1)
            DELAY_MS(50)
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(85)
            GPIOWRITE(HAPTIC,1)
			DELAY_MS(100)
			GPIOWRITE(HAPTIC,0)
            DELAY_MS(50)
            GPIOWRITE(HAPTIC,1)
            DELAY_MS(50)
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(85)
            GPIOWRITE(HAPTIC,1)
			PRINT "\n Haptics 3 finished"
			
		CASE 4                         //Very chill
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(50)
            GPIOWRITE(HAPTIC,1)
            DELAY_MS(150)
            GPIOWRITE(HAPTIC,0)
            DELAY_MS(50)
            GPIOWRITE(HAPTIC,1)
         
            PRINT "\n Haptics 4 finished"

            //add cases as required
                 
        CASE ELSE     
            PRINT "\n Not a valid haptics pattern"

    ENDSELECT

endsub

sub CHAR_SLOPE_FLAG_UPDATE() //Sub routine to update Slopes characteristic with value of SLOPE_FLAG
    dim value$ as string
	rc = BleEncode8(value$,SLOPE_FLAG,0)
    //if nTxBufs > 0 then
	rc = BleCharValueNotify(hcharSlopes,value$)
        //print "\n updated slope flag \n"
	//	nTxBufs = nTxBufs-1
	//endif
    
endsub

sub ENABLE_RX_TX() //enable optical RX and TX
	GPIOWRITE(TX_EN,HIGH)
	GPIOWRITE(RX_EN,HIGH)
endsub

sub DISABLE_RX_TX() //disable optical RX and TX
	GPIOWRITE(TX_EN,LOW)
	GPIOWRITE(RX_EN,LOW)
endsub

//FSM STATE ROUTINES--------------------------------------------------------------


sub TURN_OFF_ROUTINE()
	
	OUTPUT_STATE(TURN_OFF)
	CANCEL_ALL_TIMERS()
	DISABLE_RX_TX()
	rc = BleAdvertStop()
	GPIOWRITE(BUCK_ON,0)
	print "\n TURN_OFF state start \n"
endsub


sub LP_MODE_ROUTINE()
	CANCEL_ALL_TIMERS()
	OUTPUT_STATE(MODE_LP)

	FEEDBACK_COUNT = 0//reset feedback count variable and then send over BLE
	dim value$ as string
	rc = BleEncode8(value$,FEEDBACK_COUNT,0)
	rc = BleCharValueNotify(hcharHFeedbackCount,value$)
	
	DELAY_MS(2000)

	ENABLE_RX_TX()
	TimerStart (3,Battery_Check_Interval,1)
	
	print "\n LP_MODE state start \n"
	TimerStart (0,TARGET_BLINK_INTERVAL,1) // Reoccuring BLINK INTERVAL TIMER
	print "\n started target blink interval timer \n"
	//TimerStart (1,LP_MODE_HOUSEKEEPING_INTERVAL, 1) // Reoccuring housekeeping timer
	//print "\n started housekeeping interval timer \n"
endsub 



sub HP_MODE_ROUTINE()  //HIGH POWER MODE SETUP ROUTINE
	CANCEL_ALL_TIMERS()
	OUTPUT_STATE(MODE_HP) //cancel all existing timers and set CURRENT_STATE to MODE_HP

	FEEDBACK_COUNT = 0	//reset feedback count variable and then send over BLE
	dim value$ as string
	rc = BleEncode8(value$,FEEDBACK_COUNT,0)
	rc = BleCharValueNotify(hcharHFeedbackCount,value$)


	DELAY_MS(2000)
	ENABLE_RX_TX()
	
	print "\n HP_MODE state start \n"
    //OPTICAL_TX(CURRENT_SET_DC) //start TX with desired current
	
	//print "\n OPTICAL_TX  FINISH \n"
    TimerStart (3,Battery_Check_Interval,1)
    TimerStart(4, SAMPLE_INTERVAL,1)
    TimerStart (0,TARGET_BLINK_INTERVAL,1) // Reoccuring BLINK INTERVAL TIMER

endsub


sub CAL_PASS_ROUTINE()
	OUTPUT_STATE(CAL_PASS)
	print" \n CAL_PASS state start \n"
	LP_MODE_ROUTINE()
endsub 


sub CALIBRATION_ROUTINE()
	OUTPUT_STATE(CALIBRATION)
	CANCEL_ALL_TIMERS()
	print "\n CALIBRATION state start \n"
	
	IF CALIBRATION_STATUS == 1 THEN
		CAL_PASS_ROUTINE()
	ELSEIF CALIBRATION_STATUS == 0 THEN
	//CAL_FAIL_CODE BASICALLY	
		CURRENT_STATE = CAL_FAIL
		print "\n CAL_FAIL state start \n"
		Cal_Fail_Count = Cal_Fail_Count + 1
		print "\n CAL_FAIL COUNT = "; Cal_Fail_Count
	
		IF Cal_Fail_Count < 3 THEN
			CALIBRATION_ROUTINE()
		ELSEIF Cal_Fail_Count >= 3 THEN
			Cal_Fail_Count = 0
			TURN_OFF_ROUTINE()
		ELSE
			print "\n CAL_FAIL_ROUTINE error with Cal_Fail_Count \n"
		ENDIF
	ELSE
		print "\nsome other issue with calibraiton_routine \n"
	ENDIF
	//go through calibration steps 
	// if calibration success then CAL_PASS_ROUTINE
	// if calibration fail then CAL_FAIL_ROUTINE
	//calibration events, depending on result of this function CAL_PASS or CAL_FAIL will be called 
	
endsub 


sub CAL_FAIL_ROUTINE()
	OUTPUT_STATE(CAL_FAIL)
	print "\n CAL_FAIL state start \n"
	Cal_Fail_Count = Cal_Fail_Count + 1
	print "\n CAL_FAIL COUNT = "; Cal_Fail_Count
	
	IF Cal_Fail_Count < 3 THEN
		CALIBRATION_ROUTINE()
	ELSEIF Cal_Fail_Count >= 3 THEN
		Cal_Fail_Count = 0
		TURN_OFF_ROUTINE()
	ELSE
		print "\n CAL_FAIL_ROUTINE error with Cal_Fail_Count \n"
	ENDIF
endsub


sub PROXIMITY_DETECT_ROUTINE()
	CANCEL_ALL_TIMERS()
	OUTPUT_STATE(PROXIMITY_DETECT)
	print "\n PROXIMITY_DETECT state start \n"
	CALIBRATION_ROUTINE()
endsub



sub BLE_CONNECT_ROUTINE() //BLE CONNECT FSM STATE ROUTINE
	OUTPUT_STATE(BLE_CONNECT) //update CURRENT_STATE to BLE_CONNECT and update characteristic
	DISABLE_RX_TX()
	CANCEL_ALL_TIMERS()

	rc = BleAdvertStop()
	rc = BleDisconnect(nCtx) //reset timers and disconnect any current connections and advertisements
	
	CreateSvc() //create service
	
	rc = BleGapSvcInit(dn$, DEVICENAME_WRITABLE,APPEARANCE,MIN_CONN_INTERVAL,MAX_CONN_INTERVAL,CONN_SUP_TIMEOUT ,SLAVE_LATENCY) //initialize service characteristics
	print "\n Svc setup \n"
	MAKE_ADVERT_RPTS() //create advert reports
	print "\n Svc setup \n"
	START_ADVERTISING() //start advertising allowing device to be connectable
	print "\n check for adv \n"
endsub  


sub TURN_ON_ROUTINE() //TURN_ON FSM STATE ROUTINE
	GPIOWRITE(BUCK_ON,1) 
	OUTPUT_STATE(TURN_ON)
	CANCEL_ALL_TIMERS()

	print "\n TURN_ON state start \n"
	IO_Config() //configure inputs 
	
	IF HW_Debug == 0 THEN //IF HW DEBUG == 0 then go straight to BLE_CONNECT, OTHERWISE GO TO LP_MODE_ROUTINE
		BLE_CONNECT_ROUTINE()
	ELSE
		LP_MODE_ROUTINE()
	ENDIF
endsub

//Handlers---------------------------------------------------------------

//STATE and TIMER HANDLERS

function CHANGE_MODE_HNDL() //CHANGE_MODE Button handler, fired after button presses

	dim i : i = GpioRead(PBSTAT)	// Reading input value from PBSTAT
    if i==0 then
		IF CURRENT_STATE == TURN_OFF THEN //if the  current_state is Off, then TURN_ON routine is called
			TURN_ON_ROUTINE()
		ELSEIF CHANGE_MODE_Flag == 0 THEN 
            //OPTICAL_TX(0)
			DISABLE_RX_TX()	
			CANCEL_ALL_TIMERS() 
			OUTPUT_STATE(CHANGE_MODE)	// set  state to CHANGE_MODE and reset all current timers

			TimerStart(2,5000,0) //change mode timer set to 15 seconds, record all PBSTAT button presses in the next 15 seconds (SEE TMR_2_CM_HNDL)
			print "\n Change Mode Timer [2] Start - 15 seconds \n"
			CHANGE_MODE_Flag = 1 //update change_mode flag, now this button will increase Change_mode_Counter instead
			print "\n change mode flag is now 1, should now record button presses \n"
			
		ELSE //if Change_mode_flag is 1 then increase counter value which is used in TMR_2 Handler to determine state
			CHANGE_MODE_Counter = CHANGE_MODE_Counter + 1 
			print "\n Change Mode Counter: "; CHANGE_MODE_Counter; "\n"
		ENDIF
    elseif i==1 then
    endif
endfunc 1

function SLOPE_P_BLINK_HNDL() //ON SLOPE_P rising edge detected
	
	//If FIRST_BLINK_FLAG == 1 THEN
	//LP_LAST_BLINK_TIME = GETTICKCOUNT()
	//HP_LAST_BLINK_TIME = GETTICKCOUNT()
	//FIRST_BLINK_FLAG = 0
	//ENDIF
	if (CURRENT_STATE == MODE_LP & ((GETTICKCOUNT() - LP_LAST_BLINK_TIME) > MIN_TIME_BTWN_BLINKS)) THEN //if state is LP and there the minimum time between blinks has been established
		LP_LAST_BLINK_TIME = GETTICKCOUNT()
        SLOPE_FLAG = 1 //update slope_flag
		CHAR_SLOPE_FLAG_UPDATE()
		 
		TimerCancel(0) //reset blink interval timer since a blink has been detected
		TimerStart (0,TARGET_BLINK_INTERVAL,1)
		TimerStart (1, MAX_BLINK_DURATION,0)
		print "\n Blink detected Slope P :LP Mode @"; GETTICKCOUNT(); "\n"
		

	ENDIF
    if (CURRENT_STATE == MODE_HP & ((GETTICKCOUNT() - HP_LAST_BLINK_TIME) > MIN_TIME_BTWN_BLINKS)) THEN //if state is HP and there the minimum time between blinks has been established
		HP_LAST_BLINK_TIME = GETTICKCOUNT()
        SLOPE_FLAG = 1 //update slope_flag
		CHAR_SLOPE_FLAG_UPDATE()
		print "\n SLOPEFLAG:";SLOPE_FLAG;"\n"
		TimerCancel(0) //reset blink interval timer
		TimerStart (0,TARGET_BLINK_INTERVAL,1)
		TimerStart (1, MAX_BLINK_DURATION,0)
		print "\n Blink detected Slope P :HP Mode @"; GETTICKCOUNT(); "\n"
		
	ENDIF

endfunc 1

function SLOPE_N_BLINK_HNDL() //On SLOPE_N Rising edge detected, update SLOPE_FLAG to 0 and update Characteristic value
    SLOPE_FLAG = 0
    CHAR_SLOPE_FLAG_UPDATE()
	//LP_LAST_BLINK_TIME = GETTICKCOUNT()
//	HP_LAST_BLINK_TIME = GETTICKCOUNT()
	TimerCancel(1)
	//print "\n Slope N detected @"; GETTICKCOUNT(); "\n"
endfunc 1

function TMR_0_BLINK_INTERVAL_EXCEEDED_HNDL() //Blink Interval exceeded Timer then call Haptics
	//print "\n Blink interval exceeded \n"; GETTICKCOUNT(); "\n"
	HAPTICS(1)
endfunc 1

function TMR_1_MAX_BLINK_DURATION_HNDL() //if we dont detect slope_n, this timer should fire
	IF CURRENT_STATE == MODE_LP || MODE_HP THEN	
		SLOPE_FLAG = 0
		CHAR_SLOPE_FLAG_UPDATE()
		
		LP_LAST_BLINK_TIME = GETTICKCOUNT() //set last blink time
		HP_LAST_BLINK_TIME = GETTICKCOUNT()
		
		print "\n MAX BLINK DURATION TIMER FIRED @"; GETTICKCOUNT(); "\n"
	ENDIF
endfunc 1

function TMR_2_CHANGE_MODE_HNDL() //Change Mode Timer Handler
	DIM rc_CM : rc_CM = 1
	FIRST_BLINK_FLAG = 1
	if CHANGE_MODE_Counter == 1 then //depending on change mode counter value (obtained when pressing change mode button PBSTAT), change CURRENT_STATEstate
		OUTPUT_STATE(TURN_OFF)
		//rc_CM = 0
	elseif CHANGE_MODE_Counter == 2 then
		OUTPUT_STATE(BLE_CONNECT)
	elseif CHANGE_MODE_Counter == 3 then
		OUTPUT_STATE(MODE_HP)
	elseif CHANGE_MODE_Counter == 4 then
		OUTPUT_STATE(MODE_LP)
	ELSE
		OUTPUT_STATE(TURN_OFF)
	ENDIF
		//if statements to determine state
	print " \n Change Mode Counter: "; CHANGE_MODE_Counter
	print " \n Current State: "; CURRENT_STATE; "\n"
	
	CHANGE_MODE_Flag=0 //reset Change mode variables
	CHANGE_MODE_Counter =0
	
	print "\n Change Mode Flag and Counter reset to 0 \n \n"
	
	SELECT CURRENT_STATE //fire FSM_STATE routine according to value of Current State
		CASE TURN_OFF
			TURN_OFF_ROUTINE()
		CASE BLE_CONNECT
			BLE_CONNECT_ROUTINE()
		CASE MODE_HP
			HP_MODE_ROUTINE()
		CASE MODE_LP
			LP_MODE_ROUTINE()
		CASE ELSE
			TURN_OFF_ROUTINE()
	ENDSELECT

endfunc rc_CM

function TMR_3_BAT_ADC_HNDL() //Read Battery ADC Timer
	dim adc: adc = GPIOREAD(BAT_ADC) //obtain raw adc value from BAT_ADC pin
	//dim V_BAT as FLOAT: V_BAT = (adc) / (256*((0.25)/0.6)) * 2*1000 //Use value and characteristics of that battery adc to convert to V

   // dim V_BAT_MIN : V_BAT_MIN = 3600 //minimum value V_Bat can be 
   // dim V_BAT_MAX : V_BAT_MAX = 4200 //maximum value V_Bat can be
    //dim V_BAT_NORMALIZED as FLOAT : V_BAT_NORMALIZED = (V_BAT-V_BAT_MIN) / (V_BAT_MAX-V_BAT_MIN)*100 //normalize V_BAT and multiply 
    //dim V_BAT_NORMALIZED_INT : V_BAT_NORMALIZED_INT =  ROUND(V_BAT_NORMALIZED)
   // dim V_BAT_INT : V_BAT_INT = ROUND(V_BAT)

    
  //  IF V_BAT_NORMALIZED_INT > 100 THEN
 //       V_BAT_NORMALIZED_INT = 100
 //   ELSEIF V_BAT_NORMALIZED_INT < 0 THEN
  //      V_BAT_NORMALIZED_INT = 0
  //  ENDIF

   // SELECT V_BAT
  //      CASE >4200
            


  //      CASE ELSE
    //        print "\n nonvalid battery level \n"
   // ENDSELECT

	dim value$ as string //encode normalize V_BAT into value$ and then send value$ to be value of battery ADC
	dim value
	rc = BleEncode16 (value$,adc,0)
    
    if nTxBufs > 0 then
		rc = BleCharValueNotify(hcharBatADC,value$)
		//print "\n ADC value"; adc;"\n"
       // print "V_BAT:";V_BAT_INT;"\n"
		//value = BleDecodeU16(value$, value, 0)
		//print "value: "; value; "\n"
        //print "\n V_BAT_NORMALIZED:"; V_BAT_NORMALIZED; "\n"
        //print "\n V_BAT_NORMALIZED INT:"; V_BAT_NORMALIZED_INT; "\n"
      //  dim x
      //  rc = BleDecodeS8(value$,x,0)
    //    print "\n V_BAT_NORMALIZE DECODED: "; x; "\n"
		
		
	//	print "\nFree space in ad report: "; BleAdvRptGetSpace(adRpt$); " bytes"
	//	print "\nFree space in scan report: "; BleAdvRptGetSpace(scnRpt$); " bytes \n"
		nTxBufs = nTxBufs-1
	endif
endfunc 1

function TMR_4_HNDLR_HP_MODE_ENV_ADC() //On Timer interval (10ms) read ENV_ADC SIO pin, encode, and then send value to EnvADC Characteristic

	ADC_RAW = GPIOREAD(ENV_ADC)  
    dim value$ as string
	rc = BleEncode8(value$,ADC_RAW,0)
    if nTxBufs > 0 then
		rc = BleCharValueNotify(hcharEnvADC,value$)
		nTxBufs = nTxBufs-1
	endif
endfunc 1


//BLUETOOTH HANDLERS---------------------------------------------------

function HNDLRBLEADVTIMEOUT()   //If advertising interval expires, stop advertising
	print "\n Advert stopped from timeout" 
	print "\n Exiting..."
	rc = BleAdvertStop()
	
endfunc 1 

Function HndlrBleMsg(ByVal nMsgId, ByVal connHndl) //called whenever BLE connect or disconnect
    if nMsgID==BLE_EVBLEMSGID_DISCONNECT then //if disconnect then HNDLRDiscon will be called, this simply prints a message to the console
		HAPTICS(3)
        print "\n\n-- Disconnected from client\n"

		
    elseif nMsgID==BLE_EVBLEMSGID_CONNECT then //upon connection begin next state in state machine: Proximity Detect
        print "\n-- Connected to client"
		HAPTICS(3)
		PROXIMITY_DETECT_ROUTINE()
		nCtx = connHndl
    endif
EndFunc 1

Function HndlrDiscon(hConn, rsn) //upon BLE disconnection, cancel all existing timers, return to advertising state
	CANCEL_ALL_TIMERS()
    START_ADVERTISING() //BLE_CONNECT_ROUTINE() ? 
EndFunc 1

Function HndlrCharHvc(hChar)
    nTxBufs = nTxBufs + 1
EndFunc 1

Function HndlrCccd(charHndl, val)  
    if charHndl == hcharBatADC then //if returned characteristic desciptor: CCCD is value two then indicate to console that it has been enabled
        print "\n CCCD:";val
        if val==2 then
            AssertRC(rc,309)
            AssertRC(rc,311)
            print "\n Indications enabled"
            nTxBufs = nTxBufs + 1
        else
            print "\n Indications disabled"
        endif
    
    elseif charHndl == hcharEnvADC then
        print "\n CCCD:";val
        if val==2 then
            AssertRC(rc,309)
            AssertRC(rc,311)
            print "\n Indications enabled"
            nTxBufs = nTxBufs + 1
        else
            print "\n Indications disabled"
        endif
    
	elseif charHndl == hcharCurrentState then
        print "\n CCCD:";val
        if val==2 then
            AssertRC(rc,309)
            AssertRC(rc,311)
            print "\n Indications enabled"
            nTxBufs = nTxBufs + 1
        else
            print "\n Indications disabled"
        endif
    
    elseif charHndl == hcharHFeedbackCount then
        print "\n CCCD:";val
        if val==2 then
            AssertRC(rc,309)
            AssertRC(rc,311)
            print "\n Indications enabled"
            nTxBufs = nTxBufs + 1
        else
            print "\n Indications disabled"
        endif
    
    elseif charHndl == hcharSlopes then
        print "\n CCCD:";val
        if val==2 then
            AssertRC(rc,309)
            AssertRC(rc,311)
            print "\n Indications enabled"
            nTxBufs = nTxBufs + 1
        else
            print "\n Indications disabled"
        endif
    
    elseif charHndl == hcharTargetInterval then
        print "\n CCCD:";val
        if val==2 then
            AssertRC(rc,309)
            AssertRC(rc,311)
            print "\n Indications enabled"
            nTxBufs = nTxBufs + 1
        else
            print "\n Indications disabled"
        endif
    endif
EndFunc 1

Function HndlrTargetTimeInterval(charHndl, offset, len)   //receive Target_Blink_Interval Characteristic from Client and overwrite default of 10000
    dim data$ //data from characteristic (in hex)
	dim value //Integer variable

    rc=BleCharValueRead(charHndl, data$) //read characteristic from client
    print "\nNew value received from client:";data$
	
    rc = BleDecodeU16(data$,value,0) //decodes data$ and puts result into value. Set TARGET_BLINK_INTERVAL variable to value 
    TARGET_BLINK_INTERVAL = value

	IF TARGET_BLINK_INTERVAL > 20000 THEN //limit TARGET_BLINK_INTERVAL to be within 5 seconds or 30 seconds
		//print "exceed target blink interval, set to 30000 \n"
		TARGET_BLINK_INTERVAL = 20000
	ELSEIF TARGET_BLINK_INTERVAL < 1000 THEN
		//print "\n Target blink interval too low, set to 5000 \n"
		TARGET_BLINK_INTERVAL = 1000
	ENDIF



	//print "\n S$:"; BleDecodeU16(s$,value,0); "\n"
	//print "\n NEW VALUE FOR TARGEET BLINK ITNERVAL: "; value; "\n"
	//print "actual Target Blink Interval Found: "; TARGET_BLINK_INTERVAL; "\n"
	
    IF CURRENT_STATE == MODE_HP || CURRENT_STATE == MODE_LP THEN //If currently in an operating mode when characteristic value is read, reset Blink Interval Timer (Timer 0)
	TimerCancel(0)
	TimerStart(0,TARGET_BLINK_INTERVAL,1)
	ENDIF

EndFunc 1



//Main Program-----------------------------------------------------------
rc = gpiobindevent(2,PBSTAT,1)              //Binds a gpio transition high or low to an event for button 3 - representing PBSTAT
AssertRC(rc, 142)
rc = gpiobindevent(1,SLOPE_P,0)             //binds event to gpiochannel1 for when Slope P is active, this is for LP mode only
rc = gpiobindevent(0,SLOPE_N,0)

onevent evgpiochan2 		call CHANGE_MODE_HNDL      //Detects when button 3 is pressed or released and calls the function
onevent evgpiochan1 		call SLOPE_P_BLINK_HNDL
onevent evgpiochan0         call SLOPE_N_BLINK_HNDL
ONEVENT EVBLE_ADV_TIMEOUT 	CALL HNDLRBLEADVTIMEOUT
OnEvent EvDiscon     		call HndlrDiscon
OnEvent EvCharHvc    		call HndlrCharHvc 
OnEvent EvBleMsg     		call HndlrBleMsg   
OnEvent EvCharCccd  		call HndlrCccd
Onevent EvCharVal			call HndlrTargetTimeInterval

onevent EVTMR0 				CALL TMR_0_BLINK_INTERVAL_EXCEEDED_HNDL
onevent EVTMR1 				CALL TMR_1_MAX_BLINK_DURATION_HNDL
onevent EVTMR2 				CALL TMR_2_CHANGE_MODE_HNDL  //Timer 2 which is associated with change mode button presses
onevent EVTMR3 				call TMR_3_BAT_ADC_HNDL
onevent EVTMR4              call TMR_4_HNDLR_HP_MODE_ENV_ADC

TURN_ON_ROUTINE()

print "\n waitevent \n"
WAITEVENT 

